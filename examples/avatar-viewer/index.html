<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Avatar viewer â€“ Dance Hack</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; background: #0a0a12; color: #eee; font-family: system-ui, sans-serif; overflow: hidden; }
    #canvas3d { display: block; width: 100%; height: 100vh; }
    .waiting {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 1.5rem 2rem;
      background: rgba(0,0,0,0.75);
      border-radius: 12px;
      text-align: center;
      z-index: 5;
      max-width: 90%;
    }
    .waiting.hidden { display: none; }
    .waiting a { color: #0af; }
  </style>
</head>
<body>
  <canvas id="canvas3d"></canvas>
  <div class="waiting" id="waiting">
    <p><strong>Waiting for stream</strong></p>
    <p>Open <a href="../skeleton-webcam-output/">skeleton-webcam-output</a>, check <strong>Stream to avatar</strong>, then move in front of the camera.</p>
    <p><small>Both tabs must be from the same origin (e.g. same Live Server).</small></p>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const POSE_CONNECTIONS = [
      [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
      [11, 23], [12, 24], [23, 24], [23, 25], [25, 27], [27, 29], [27, 31],
      [24, 26], [26, 28], [28, 30], [28, 32],
      [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
      [9, 10], [15, 17], [15, 19], [15, 21], [16, 18], [16, 20], [16, 22]
    ];

    const canvas = document.getElementById('canvas3d');
    const waitingEl = document.getElementById('waiting');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a12);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 100);
    camera.position.set(0, 0.5, 2);
    camera.lookAt(0, 0.3, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const controls = new OrbitControls(camera, canvas);
    controls.target.set(0, 0.3, 0);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0x404060));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(2, 3, 2);
    scene.add(dir);

    const skeletonGroup = new THREE.Group();
    skeletonGroup.rotation.x = Math.PI;
    scene.add(skeletonGroup);

    const SCALE = 1.2;
    const skinMat = new THREE.MeshPhongMaterial({
      color: 0xedb894,
      shininess: 25,
      flatShading: true
    });

    // T-pose character: torso, head, limbs (MediaPipe indices: 0=nose, 11/12=shoulders, 13/14=elbows, 15/16=wrists, 23/24=hips, 25/26=knees, 27/28=ankles)
    const BODY_PARTS = [
      { type: 'torso', radius: 0.09 },
      { type: 'head', radius: 0.07 },
      { start: 11, end: 13, radius: 0.04 },
      { start: 12, end: 14, radius: 0.04 },
      { start: 13, end: 15, radius: 0.032 },
      { start: 14, end: 16, radius: 0.032 },
      { start: 23, end: 25, radius: 0.05 },
      { start: 24, end: 26, radius: 0.05 },
      { start: 25, end: 27, radius: 0.038 },
      { start: 26, end: 28, radius: 0.038 }
    ];

    let bodyMeshes = [];
    const _v0 = new THREE.Vector3();
    const _v1 = new THREE.Vector3();
    const _mid = new THREE.Vector3();
    const _up = new THREE.Vector3(0, 1, 0);

    function getPt(world, i) {
      const p = world[i];
      return _v0.set(
        (p[0] != null ? p[0] : p.x) * SCALE,
        (p[1] != null ? p[1] : p.y) * SCALE,
        (p[2] != null ? p[2] : p.z) * SCALE
      );
    }

    function createSkeletonMeshes() {
      const cylGeo = new THREE.CylinderGeometry(1, 1, 1, 12);
      const sphereGeo = new THREE.SphereGeometry(1, 16, 12);
      for (let i = 0; i < BODY_PARTS.length; i++) {
        const part = BODY_PARTS[i];
        const mesh = part.type === 'head'
          ? new THREE.Mesh(sphereGeo.clone(), skinMat.clone())
          : new THREE.Mesh(cylGeo.clone(), skinMat.clone());
        bodyMeshes.push(mesh);
        skeletonGroup.add(mesh);
      }
    }

    function updateSkeletonFromWorld(world) {
      if (!world || world.length < 33 || bodyMeshes.length === 0) return;
      for (let i = 0; i < BODY_PARTS.length; i++) {
        const part = BODY_PARTS[i];
        const mesh = bodyMeshes[i];
        if (part.type === 'torso') {
          getPt(world, 11);
          _mid.copy(_v0);
          getPt(world, 12);
          _mid.add(_v0).multiplyScalar(0.5);
          getPt(world, 23);
          _v1.copy(_v0);
          getPt(world, 24);
          _v1.add(_v0).multiplyScalar(0.5);
          const dist = _mid.distanceTo(_v1);
          if (dist < 0.001) continue;
          mesh.position.lerpVectors(_mid, _v1, 0.5);
          mesh.scale.set(part.radius * 2, dist, part.radius * 2);
          _v1.sub(_mid).normalize();
          mesh.quaternion.setFromUnitVectors(_up, _v1);
        } else if (part.type === 'head') {
          getPt(world, 0);
          mesh.position.copy(_v0);
          mesh.scale.setScalar(part.radius);
        } else {
          getPt(world, part.start);
          _mid.copy(_v0);
          getPt(world, part.end);
          const dist = _mid.distanceTo(_v0);
          if (dist < 0.001) continue;
          mesh.position.lerpVectors(_mid, _v0, 0.5);
          mesh.scale.set(part.radius * 2, dist, part.radius * 2);
          _v0.sub(_mid).normalize();
          mesh.quaternion.setFromUnitVectors(_up, _v0);
        }
      }
    }

    createSkeletonMeshes();

    const channel = new BroadcastChannel('dancehack-pose');
    channel.onmessage = function(e) {
      if (e.data && e.data.world) {
        waitingEl.classList.add('hidden');
        updateSkeletonFromWorld(e.data.world);
      }
    };

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
