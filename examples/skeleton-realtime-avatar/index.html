<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real-time skeleton → 3D avatar – Dance Hack</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; background: #0a0a12; color: #eee; font-family: system-ui, sans-serif; overflow: hidden; }
    #canvas3d { display: block; width: 100%; height: 100vh; }
    .webcam-preview {
      position: fixed;
      top: 1rem;
      right: 1rem;
      width: 200px;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      z-index: 5;
      border: 2px solid #333;
    }
    .webcam-preview video,
    .webcam-preview canvas {
      display: block;
      width: 100%;
      height: auto;
      vertical-align: top;
    }
    .webcam-preview canvas {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .webcam-preview .wrap { position: relative; }
    .status {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.5rem 1rem;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      font-size: 0.85rem;
      z-index: 5;
    }
    .status.ready { color: #8f8; }
    .status.error { color: #f88; }
  </style>
</head>
<body>
  <canvas id="canvas3d"></canvas>
  <div class="webcam-preview">
    <div class="wrap">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas2d"></canvas>
    </div>
  </div>
  <div id="status" class="status">Loading…</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const POSE_CONNECTIONS = [
      [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
      [11, 23], [12, 24], [23, 24], [23, 25], [25, 27], [27, 29], [27, 31],
      [24, 26], [26, 28], [28, 30], [28, 32],
      [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
      [9, 10], [15, 17], [15, 19], [15, 21], [16, 18], [16, 20], [16, 22]
    ];

    const statusEl = document.getElementById('status');
    const video = document.getElementById('video');
    const canvas2d = document.getElementById('canvas2d');
    const canvas3d = document.getElementById('canvas3d');
    const ctx2d = canvas2d.getContext('2d');

    function setStatus(msg, isError) {
      statusEl.textContent = msg;
      statusEl.className = 'status' + (isError ? ' error' : ' ready');
    }

    // —— Three.js scene ——
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a12);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 100);
    camera.position.set(0, 0.5, 2);
    camera.lookAt(0, 0.3, 0);

    const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    const controls = new OrbitControls(camera, canvas3d);
    controls.target.set(0, 0.3, 0);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0x404060));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(2, 3, 2);
    scene.add(dir);

    const skeletonGroup = new THREE.Group();
    skeletonGroup.rotation.x = Math.PI;
    scene.add(skeletonGroup);

    const SCALE = 1.2;
    const skinMat = new THREE.MeshPhongMaterial({
      color: 0xedb894,
      shininess: 25,
      flatShading: true
    });

    const BODY_PARTS = [
      { type: 'torso', radius: 0.09 },
      { type: 'head', radius: 0.07 },
      { start: 11, end: 13, radius: 0.04 },
      { start: 12, end: 14, radius: 0.04 },
      { start: 13, end: 15, radius: 0.032 },
      { start: 14, end: 16, radius: 0.032 },
      { start: 23, end: 25, radius: 0.05 },
      { start: 24, end: 26, radius: 0.05 },
      { start: 25, end: 27, radius: 0.038 },
      { start: 26, end: 28, radius: 0.038 }
    ];

    let bodyMeshes = [];
    const _v0 = new THREE.Vector3();
    const _v1 = new THREE.Vector3();
    const _mid = new THREE.Vector3();
    const _up = new THREE.Vector3(0, 1, 0);

    function getPt(world, i) {
      const p = world[i];
      return _v0.set(
        (p.x != null ? p.x : p[0]) * SCALE,
        (p.y != null ? p.y : p[1]) * SCALE,
        (p.z != null ? p.z : p[2]) * SCALE
      );
    }

    function createSkeletonMeshes() {
      const cylGeo = new THREE.CylinderGeometry(1, 1, 1, 12);
      const sphereGeo = new THREE.SphereGeometry(1, 16, 12);
      for (let i = 0; i < BODY_PARTS.length; i++) {
        const part = BODY_PARTS[i];
        const mesh = part.type === 'head'
          ? new THREE.Mesh(sphereGeo.clone(), skinMat.clone())
          : new THREE.Mesh(cylGeo.clone(), skinMat.clone());
        bodyMeshes.push(mesh);
        skeletonGroup.add(mesh);
      }
    }

    function updateSkeletonFromWorld(world) {
      if (!world || world.length < 33 || bodyMeshes.length === 0) return;
      for (let i = 0; i < BODY_PARTS.length; i++) {
        const part = BODY_PARTS[i];
        const mesh = bodyMeshes[i];
        if (part.type === 'torso') {
          getPt(world, 11);
          _mid.copy(_v0);
          getPt(world, 12);
          _mid.add(_v0).multiplyScalar(0.5);
          getPt(world, 23);
          _v1.copy(_v0);
          getPt(world, 24);
          _v1.add(_v0).multiplyScalar(0.5);
          const dist = _mid.distanceTo(_v1);
          if (dist < 0.001) continue;
          mesh.position.lerpVectors(_mid, _v1, 0.5);
          mesh.scale.set(part.radius * 2, dist, part.radius * 2);
          _v1.sub(_mid).normalize();
          mesh.quaternion.setFromUnitVectors(_up, _v1);
        } else if (part.type === 'head') {
          getPt(world, 0);
          mesh.position.copy(_v0);
          mesh.scale.setScalar(part.radius);
        } else {
          getPt(world, part.start);
          _mid.copy(_v0);
          getPt(world, part.end);
          const dist = _mid.distanceTo(_v0);
          if (dist < 0.001) continue;
          mesh.position.lerpVectors(_mid, _v0, 0.5);
          mesh.scale.set(part.radius * 2, dist, part.radius * 2);
          _v0.sub(_mid).normalize();
          mesh.quaternion.setFromUnitVectors(_up, _v0);
        }
      }
    }

    function draw2DSkeleton(landmarks) {
      if (!landmarks || landmarks.length === 0) return;
      const w = canvas2d.width;
      const h = canvas2d.height;
      ctx2d.clearRect(0, 0, w, h);
      for (let i = 0; i < POSE_CONNECTIONS.length; i++) {
        const [ai, bi] = POSE_CONNECTIONS[i];
        const a = landmarks[ai], b = landmarks[bi];
        if (!a || !b) continue;
        ctx2d.beginPath();
        ctx2d.moveTo(a.x * w, a.y * h);
        ctx2d.lineTo(b.x * w, b.y * h);
        ctx2d.strokeStyle = '#0af';
        ctx2d.lineWidth = 2;
        ctx2d.stroke();
      }
      for (let j = 0; j < landmarks.length; j++) {
        const pt = landmarks[j];
        ctx2d.beginPath();
        ctx2d.arc(pt.x * w, pt.y * h, 3, 0, Math.PI * 2);
        ctx2d.fillStyle = '#f0a';
        ctx2d.fill();
      }
    }

    createSkeletonMeshes();

    // —— MediaPipe + webcam ——
    let poseLandmarker = null;
    let lastVideoTime = -1;

    const { PoseLandmarker, FilesetResolver } = await import(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs'
    );

    try {
      const resolver = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
      );
      poseLandmarker = await PoseLandmarker.createFromOptions(resolver, {
        baseOptions: {
          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task'
        },
        runningMode: 'VIDEO',
        numPoses: 1
      });
    } catch (e) {
      setStatus('MediaPipe failed: ' + e.message, true);
      throw e;
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      setStatus('Camera error: ' + e.message, true);
      throw e;
    }

    video.addEventListener('loadedmetadata', function() {
      canvas2d.width = video.videoWidth;
      canvas2d.height = video.videoHeight;
      setStatus('Live – move in front of the camera. Drag to orbit 3D view.');
    });

    function tick() {
      if (poseLandmarker && video.readyState >= 2) {
        const now = video.currentTime * 1000;
        if (lastVideoTime !== video.currentTime) {
          lastVideoTime = video.currentTime;
          try {
            const result = poseLandmarker.detectForVideo(video, now);
            const imageLm = result.landmarks && result.landmarks[0];
            const worldLm = result.worldLandmarks && result.worldLandmarks[0];
            if (imageLm) draw2DSkeleton(imageLm);
            if (worldLm) updateSkeletonFromWorld(worldLm);
          } catch (err) { console.warn(err); }
        }
      }
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
